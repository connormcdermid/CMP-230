     1                                  ; AUTHOR: Connor McDermid
     2                                  ; DATE: 2021-11-05
     3                                  ; 64-bit Lab 7 "fibonacci"
     4                                  %include "Macros_CPsub64.inc"
     5                              <1> ;--------------------------- MACROS ------------------------------------------
     6                              <1> ; Change Log:
     7                              <1> ; 02-06-21 CP Rename ifndef for Exit from CPExit to Exit, update mShowRegister
     8                              <1> ;
     9                              <1> ;
    10                              <1> ;-----------------------------------------------------------------------------
    11                              <1> %ifndef MACRO_CPSUB64
    12                              <1> %define MACRO_CPSUB64
    13                              <1> 
    14                              <1> %define STDIN  0
    15                              <1> %define STDOUT 1
    16                              <1> %define STDERR 2
    17                              <1> 
    18                              <1> %define TAB 09h
    19                              <1> %define NL 0Ah
    20                              <1> 
    21                              <1> ; define the timespec structure used in nanosleep
    22                              <1> struc timespec
    23 00000000 ????????            <1>      tv_sec: resd 1
    24 00000004 ????????            <1>      tv_nsec: resd 1
    25                              <1> endstruc
    26                              <1> 
    27                              <1> 
    28                              <1> ; Synonym for NASM invoke
    29                              <1> %ifnmacro INVOKE
    30                              <1> %macro INVOKE 1-*.nolist
    31                              <1>      %rep %0 - 1
    32                              <1>      %rotate -1
    33                              <1>      push qword %1
    34                              <1>      %endrep
    35                              <1>      %rotate -1
    36                              <1>      call %1
    37                              <1>      add rsp, ( %0 - 1 ) * 8
    38                              <1> %endmacro
    39                              <1> %endif
    40                              <1> 
    41                              <1> 
    42                              <1> %ifnmacro mWrite
    43                              <1> ;------------------------------------------------------
    44                              <1> %macro mWrite 1.nolist
    45                              <1> ;
    46                              <1> ; Writes a string literal to standard output.
    47                              <1> ; Receives: a string enclosed in single or double 
    48                              <1> ;   quotes (null terminator not required).
    49                              <1> ;------------------------------------------------------
    50                              <1> segment .data
    51                              <1> 	%%string: db %1, 0
    52                              <1> segment .text
    53                              <1> 	push	rdx
    54                              <1> 	mov	rdx,%%string
    55                              <1>  	call	WriteString
    56                              <1>  	pop	rdx
    57                              <1> %endmacro
    58                              <1> %endif
    59                              <1> 
    60                              <1> 
    61                              <1> %ifnmacro mWriteSpace
    62                              <1> ;------------------------------------------------------
    63                              <1> %macro mWriteSpace 0-1.nolist 1
    64                              <1> ;
    65                              <1> ; Writes one or more spaces to standard output.
    66                              <1> ; Receives: an integer specifying the number of spaces.
    67                              <1> ;   If count is blank, a single space is written.
    68                              <1> ;------------------------------------------------------
    69                              <1> segment .data
    70                              <1> %%spaces: times %1 db ' '
    71                              <1> 	db 0
    72                              <1> segment .text
    73                              <1> 	push	rdx
    74                              <1> 	mov	rdx, %%spaces
    75                              <1> 	call	WriteString
    76                              <1> 	pop	rdx
    77                              <1> %endmacro
    78                              <1> %endif
    79                              <1> 
    80                              <1> 
    81                              <1> %ifnmacro mShowRegister
    82                              <1> ;---------------------------------------------------
    83                              <1> %macro mShowRegister 2.nolist
    84                              <1> ;
    85                              <1> ; Displays a 64-bit register name and its contents.
    86                              <1> ; Receives: the register string name, the register.
    87                              <1> ; Returns:  nothing
    88                              <1> ;---------------------------------------------------
    89                              <1> segment .data
    90                              <1> %%tempStr: db "  ", %1,": ",0
    91                              <1> 
    92                              <1> segment .text
    93                              <1> 	push	rax		; save reg	
    94                              <1> 	push	rdx 		; save reg
    95                              <1> 	mov	rdx, %%tempStr	; display the register name
    96                              <1> 	call	WriteString
    97                              <1> 	pop	rdx		; restore reg
    98                              <1> 	mov	rax, %2		; display the reg contents in hex
    99                              <1> 	call	WriteHex
   100                              <1> 	pop	rax             ; restore reg
   101                              <1> %endmacro
   102                              <1> %endif
   103                              <1> 
   104                              <1> 
   105                              <1> %ifnmacro ShowFlag
   106                              <1> ;---------------------------------------------------------------------
   107                              <1> %macro ShowFlag 2.nolist
   108                              <1> ;
   109                              <1> ; Helper macro.
   110                              <1> ; Display a single CPU flag value
   111                              <1> ; Directly accesses the eflags variable in Along32.asm
   112                              <1> ; (This macro cannot be placed in Macros.inc)
   113                              <1> ;---------------------------------------------------------------------
   114                              <1> segment .data
   115                              <1> %%flagStr: db "  ",%1, "="
   116                              <1> %%flagVal: db 0,0
   117                              <1> 
   118                              <1> segment .text
   119                              <1> 	push rax
   120                              <1> 	push rdx
   121                              <1> 	mov  rax, qword [eflags]	; retrieve the flags
   122                              <1> 	mov  byte [%%flagVal],'1'
   123                              <1> 	shr  rax, %2			; shift into carry flag
   124                              <1> 	jc   %%L1
   125                              <1> 	mov  byte [%%flagVal],'0'
   126                              <1> %%L1:
   127                              <1> 	mov  rdx, %%flagStr	; display flag name and value
   128                              <1> 	call WriteString
   129                              <1> 	pop  rdx
   130                              <1> 	pop  rax
   131                              <1> %endmacro
   132                              <1> %endif
   133                              <1> 
   134                              <1> 
   135                              <1> %ifnmacro ShowCC
   136                              <1> ;---------------------------------------------------------------------
   137                              <1> %macro ShowCC 2.nolist
   138                              <1> ;
   139                              <1> ; Helper macro.
   140                              <1> ; Display a single Condition Code Eflag name and value
   141                              <1> ; Directly accesses the eflags variable.
   142                              <1> ; 
   143                              <1> ;---------------------------------------------------------------------
   144                              <1> segment .data
   145                              <1> %%flagStr: db "  ",%1," : "    	; flag name plus = sign
   146                              <1> %%flagVal: db 0,0         	; flag value if 0 or 1, plus NULL
   147                              <1> 
   148                              <1> segment .text
   149                              <1> 	push rax  		; save reg
   150                              <1> 	push rdx		; save reg
   151                              <1> 	mov  rax, qword [eflags]	; retrieve the flags
   152                              <1> 	mov  byte [%%flagVal],'1'	; ON
   153                              <1> 	shr  rax, %2		; shift into carry flag
   154                              <1> 	jc   %%L1
   155                              <1> 	mov  byte [%%flagVal],'0'	; OFF
   156                              <1> %%L1:
   157                              <1> 	mov  rdx, %%flagStr	; display flag name and value
   158                              <1> 	call WriteString
   159                              <1> 	call Crlf		; line feed
   160                              <1> 	pop  rdx		; restore reg
   161                              <1> 	pop  rax		; restore reg
   162                              <1> %endmacro
   163                              <1> %endif
   164                              <1> 
   165                              <1> 
   166                              <1> 
   167                              <1> %ifnmacro CheckInit
   168                              <1> ;-------------------------------------------------------------
   169                              <1> %macro CheckInit 0.nolist
   170                              <1> ;
   171                              <1> ; Helper macro
   172                              <1> ; Check to see if the console handles have been initialized
   173                              <1> ; If not, initialize them now.
   174                              <1> ;-------------------------------------------------------------
   175                              <1> 	cmp byte [InitFlag],0
   176                              <1> 	jne %%exit
   177                              <1> 	mov byte [InitFlag],1
   178                              <1> 	call BufferFlush
   179                              <1> %%exit:
   180                              <1> %endmacro
   181                              <1> %endif
   182                              <1> 
   183                              <1> 
   184                              <1> %ifnmacro SaveRegs
   185                              <1> ;-------------------------------------------------------------
   186                              <1> %macro SaveRegs 0.nolist
   187                              <1> ;
   188                              <1> ; Convenience macro
   189                              <1> ; Save Registers
   190                              <1> ; PUSH the 16 general purpose regs to the stack.
   191                              <1> ;-------------------------------------------------------------
   192                              <1>        push rax
   193                              <1>        push rbx 
   194                              <1>        push rcx
   195                              <1>        push rdx
   196                              <1>        push rsi
   197                              <1>        push rdi
   198                              <1>        push rbp
   199                              <1>        push rsp
   200                              <1>        push r8 	
   201                              <1>        push r9  
   202                              <1>        push r10
   203                              <1>        push r11
   204                              <1>        push r12
   205                              <1>        push r13
   206                              <1>        push r14
   207                              <1>        push r15
   208                              <1> %%exit:
   209                              <1> %endmacro
   210                              <1> %endif
   211                              <1> 
   212                              <1> %ifnmacro RestoreRegs
   213                              <1> ;-------------------------------------------------------------
   214                              <1> %macro RestoreRegs 0.nolist
   215                              <1> ;
   216                              <1> ; Convenience macro
   217                              <1> ; Restore Registers
   218                              <1> ; POP the 16 general purpose regs from the stack.
   219                              <1> ;-------------------------------------------------------------
   220                              <1> 	pop r15
   221                              <1> 	pop r14
   222                              <1> 	pop r13
   223                              <1>      	pop r12
   224                              <1> 	pop r11 
   225                              <1> 	pop r10
   226                              <1>      	pop r9 
   227                              <1>      	pop r8 
   228                              <1> 	pop rsp
   229                              <1>       	pop rbp 
   230                              <1>       	pop rdi
   231                              <1>       	pop rsi
   232                              <1>       	pop rdx
   233                              <1>       	pop rcx 
   234                              <1>       	pop rbx
   235                              <1>       	pop rax
   236                              <1> %%exit:
   237                              <1> %endmacro
   238                              <1> %endif
   239                              <1> 
   240                              <1> ; Termination Macro
   241                              <1> ;-------------------------------------------------------------
   242                              <1> ;
   243                              <1> ; Convenience macro
   244                              <1> ; Exit to operating system under Linux.
   245                              <1> ;-------------------------------------------------------------
   246                              <1> %ifnmacro Exit
   247                              <1> %macro Exit 0.nolist  
   248                              <1>      mov rax, 60
   249                              <1>      xor rdi, rdi
   250                              <1>      syscall
   251                              <1> %%exit:
   252                              <1> %endmacro
   253                              <1> %endif
   254                              <1> 
   255                              <1> ; Termination Macro
   256                              <1> %ifnmacro CPexit
   257                              <1> ;-------------------------------------------------------------
   258                              <1> ;
   259                              <1> ; Convenience macro
   260                              <1> ; Exit to operating system under Linux.
   261                              <1> ;-------------------------------------------------------------
   262                              <1> %macro CPexit 0-1.nolist  
   263                              <1>      mov rax, 60
   264                              <1>      xor rdi, rdi
   265                              <1>      syscall
   266                              <1> %%exit:
   267                              <1> %endmacro
   268                              <1> %endif
   269                              <1> 
   270                              <1> %endif  ;End of Macro Definitions
     5                                  %include "CPsub64.inc"
     6                              <1> ; Last update: 2019/08/20
     7                              <1> 
     8                              <1> %ifndef CPSUB64
     9                              <1> %define CPSUB64
    10                              <1> 
    11                              <1> ; ------------------------------------------
    12                              <1> ; function prototypes
    13                              <1> ; ------------------------------------------
    14                              <1> extern Clearscr
    15                              <1> extern CloseFile
    16                              <1> extern Crlf
    17                              <1> extern ClearBuffer
    18                              <1> extern Delay
    19                              <1> extern DumpMem
    20                              <1> extern DumpCC
    21                              <1> extern DumpEflags
    22                              <1> extern DumpRegs
    23                              <1> extern IsDigit
    24                              <1> extern Mvcl
    25                              <1> extern FileOpen
    26                              <1> extern FileClose
    27                              <1> extern FileRead
    28                              <1> extern FileWrite
    29                              <1> extern ParseDecimal32
    30                              <1> extern ParseInteger32
    31                              <1> extern ParseDecimal64
    32                              <1> extern ParseInteger64
    33                              <1> extern ReadChar
    34                              <1> extern ReadDec
    35                              <1> extern ReadHex
    36                              <1> extern ReadInt
    37                              <1> extern ReadKey
    38                              <1> extern ReadString
    39                              <1> extern ReadStr
    40                              <1> extern Str_compare
    41                              <1> extern Str_copy
    42                              <1> extern Str_length
    43                              <1> extern StrLength
    44                              <1> extern Str_trim
    45                              <1> extern Str_ucase
    46                              <1> extern WriteBin
    47                              <1> extern WriteBinB
    48                              <1> extern WriteChar
    49                              <1> extern WriteDec
    50                              <1> extern WriteHex
    51                              <1> extern WriteHexDbl
    52                              <1> extern WriteHexB
    53                              <1> extern WriteInt
    54                              <1> extern WriteString
    55                              <1> ; ------------------------------------------
    56                              <1> 
    57                              <1> %endif
     6                                  
     7                                  global	main	; global entry point export for ld
     8                                  
     9                                  section .data
    10 00000000 50726F6772616D2074-     eopmsg	db	"Program terminating.",00h
    10 00000009 65726D696E6174696E-
    10 00000012 672E00             
    11 00000015 546865206E756D6265-     negmsg	db	"The number must be positive.",00h	; remember null terminators
    11 0000001E 72206D757374206265-
    11 00000027 20706F736974697665-
    11 00000030 2E00               
    12 00000032 506C6561736520656E-     prompt	db	"Please enter the quantity of fibonacci numbers you'd like: ",00h
    12 0000003B 746572207468652071-
    12 00000044 75616E74697479206F-
    12 0000004D 66206669626F6E6163-
    12 00000056 6369206E756D626572-
    12 0000005F 7320796F752764206C-
    12 00000068 696B653A2000       
    13 0000006E 20<rep FFh>             ipbuf	times	255 db	20h 	; define buffer of whitespace
    14                                  ipbufln	equ	$-ipbuf
    15 0000016D 496E74656765722069-     invmsg	db	"Integer is not valid. Please try again."
    15 00000176 73206E6F742076616C-
    15 0000017F 69642E20506C656173-
    15 00000188 652074727920616761-
    15 00000191 696E2E             
    16                                  
    17                                  section .text
    18                                  
    19                                  ;------------------------------------------------------
    20                                  ; SUBROUTINE: fpcvt
    21                                  ; INPUTS: One IEEE-754 encoded floating point number
    22                                  ; OUTPUTS: One string-encoded decimal floating point number
    23                                  ; A probably fairly complicated bit hack to manually convert since I can't find any
    24                                  ; instructions or libraries to do it for me.
    25                                  fpcvt:
    26                                  	; subroutine prologue
    27 00000000 55                      	push	rbp	; save caller base pointer
    28 00000001 4889E5                  	mov	rbp, rsp; new base pointer
    29 00000004 4883EC10                	sub	rsp, 2*8; allocate x local vars if needed
    30 00000008 50                      	push	rax
    31 00000009 53                      	push	rbx	; save working regs
    32                                  
    33                                  	; subroutine body
    34                                  	; fetch parameter into xmm0
    35 0000000A F30F6F4508              	movdqu	xmm0, [rbp + 8]
    36                                  	; while technically signed, our float will *always* be positive, so
    37                                  	; I don't care about the sign bit
    38                                  	; next, parse exponent
    39                                  	; make bitmask for only the first 16 bits minus the sign bit -- 
    40                                  	; 0x7FFF0000000000000000000000000000
    41 0000000F 488945F8                	mov	[rbp - 8], rax	; save rax as local var
    42                                  	andpd	xmm0, 0x7FFF0000000000000000000000000000
    42          ******************       warning: numeric constant 0x7FFF0000000000000000000000000000 does not fit in 64 bits [-w+number-overflow]
    42          ******************       error: invalid combination of opcode and operands
    43                                  	shr	xmm0, 28	; bitshift 28 to the right
    43          ******************       error: invalid combination of opcode and operands
    44 00000013 66480F7EC0              	movq	rax, xmm0
    45 00000018 482DFF030000            	sub	rax, 1023 ; unbias exponent (double exponent bias is 1023)
    46                                  	; exponent now in RAX
    47 0000001E 488B5DF8                	mov	rbx, [rbp - 8] ; copy original from local var into RBX
    48                                  	; bitmask for final 52 bits
    49                                  	; 0x000FFFFFFFFFFFFF
    50                                  	andpd	xmm0, 0x0000FFFFFFFFFFFFFFFFFFFFFFFFFFFF; rbx now contains mantissa or fractional significand
    50          ******************       warning: numeric constant 0x0000FFFFFFFFFFFFFFFFFFFFFFFFFFFF does not fit in 64 bits [-w+number-overflow]
    50          ******************       error: invalid combination of opcode and operands
    51                                  	; no bitshift needed	
    52                                  	; need a test of the endianness of the mantissa
    53 00000022 488945F0                	mov	[rbp - 16], rax	; second local variable now contains exponent
    54 00000026 66480F7EC0              	movq	rax, xmm0
    55 0000002B E8(00000000)            	call	WriteInt
    56                                  
    57                                  	; subroutine epilogue
    58 00000030 5B                      	pop rbx
    59 00000031 58                      	pop rax
    60 00000032 4883C410                	add	rsp, 2*8; deallocate x local vars
    61 00000036 4889EC                  	mov	rsp, rbp
    62 00000039 5D                      	pop	rbp
    63 0000003A C3                      	ret
    64                                  ;
    65                                  ;-------------------------------------------------------
    66                                  
    67                                  ;-------------------------------------------------------
    68                                  ; SUBROUTINE: phi
    69                                  ; INPUTS: two integers fib(n-1) and fib(n)
    70                                  ; OUTPUTS: approximation of phi in XMM0
    71                                  ; Uses SSE registers because I can't be bothered to bit-hack my way to infinitely more accurate values of phi
    72                                  ; On x86-64 Unix *all* SSE registers are scratch registers -- I have no responsibility to save any of them.
    73                                  phi:
    74                                  	; subroutine prologue
    75 0000003B 55                      	push	rbp	; save caller base pointer
    76 0000003C 4889E5                  	mov	rbp, rsp; new base pointer
    77                                  	;sub	rsp, x*8; allocate x local vars if needed
    78 0000003F 50                      	push	rax
    79 00000040 53                      	push	rbx
    80                                  
    81                                  	; subroutine body
    82 00000041 488B4510                	mov	rax, [rbp + 2*8]; retrieve param 1 (fib(n-1))
    83 00000045 488B5D18                	mov	rbx, [rbp + 3*8]; retrieve param 2 (fib(n))
    84                                  	; convert integers to double-precision floats
    85 00000049 F2480F2AC0              	cvtsi2sd xmm0, rax; cvtsi2sd = convert signed integer to signed double
    86 0000004E F2480F2ACB              	cvtsi2sd xmm1, rbx
    87                                  	; now divide them
    88 00000053 F20F5EC1                	divsd	xmm0, xmm1 ; divide signed double
    89                                  	; result now stored as double-precision floating point in xmm0
    90                                  	; now move it to a general-purpose register so it can be used by the rest of the program
    91                                  	; *without* clobbering the floating-pointedness
    92                                  	;movq	rcx, xmm0	; move quadword
    93                                  	; done
    94                                  
    95                                  	; subroutine epilogue
    96 00000057 5B                      	pop	rbx
    97 00000058 58                      	pop	rax
    98                                  	;add	rsp, x*8; deallocate local vars
    99 00000059 4889EC                  	mov	rsp, rbp
   100 0000005C 5D                      	pop	rbp
   101 0000005D C3                      	ret
   102                                  
   103                                  ;--------------------------------------------------------
   104                                  
   105                                  ;--------------------------------------------------------
   106                                  ; SUBROUTINE: fib
   107                                  ; INPUTS: Quantity
   108                                  ; OUTPUTS: Requested numbers in RAX
   109                                  fib:
   110                                  	; subroutine prologue
   111 0000005E 55                      	push	rbp	; save caller base pointer
   112 0000005F 4889E5                  	mov	rbp, rsp; new base pointer
   113 00000062 4883EC18                	sub	rsp, 3*8; allocate 3 local vars on stack
   114 00000066 53                      	push	rbx	; save caller regs
   115 00000067 51                      	push	rcx	; for use as working regs
   116                                  	
   117                                  	; subroutine body
   118 00000068 488B4510                	mov	rax, [rbp + 2*8]; retrieve parameter
   119 0000006C 4883F801                	cmp	rax, 1		; if n = 1
   120 00000070 7E34                    	jle	return		; return from subroutine
   121                                  				; else, continue
   122 00000072 BB01000000              	mov	rbx, 1
   123 00000077 B902000000              	mov	rcx, 2
   124 0000007C 50                      	push 	rax	; preserve original value of RAX
   125 0000007D 4829D8                  	sub	rax, rbx	; n - 1
   126 00000080 4889C3                  	mov	rbx, rax	; rbx should hold n - 1 value
   127 00000083 58                      	pop	rax		; restore value of RAX
   128 00000084 4829C8                  	sub	rax, rcx	; n - 2
   129 00000087 4889C1                  	mov	rcx, rax	; rcx should hold n - 2 value
   130 0000008A 53                      	push	rbx		; pass n - 1 to fib()
   131 0000008B E8CEFFFFFF              	call	fib
   132 00000090 5B                      	pop	rbx
   133 00000091 4889C3                  	mov	rbx, rax	; fib(n - 1) now in RBX
   134 00000094 51                      	push	rcx		; pass n - 2 to fib()
   135 00000095 E8C4FFFFFF              	call	fib
   136 0000009A 59                      	pop 	rcx
   137 0000009B 4889C1                  	mov	rcx, rax	; fib(n - 2) now in RCX
   138                                  				; yeah, yeah, I could just use RAX, but this is more readable
   139                                  	
   140 0000009E 4801CB                  	add	rbx, rcx	; fib(n - 1) + fib(n - 2)
   141 000000A1 4889D8                  	mov	rax, rbx	; move result of fib function to RAX for return
   142 000000A4 EB00                    	jmp	return
   143                                  	
   144                                  return	equ	$
   145                                  	; subroutine epilogue
   146 000000A6 59                      	pop	rcx		; restore caller regs
   147 000000A7 5B                      	pop	rbx	
   148 000000A8 4883C418                	add	rsp, 3*8	; clear stack of local var allocations
   149 000000AC 4889EC                  	mov	rsp, rbp	; restore caller stack pointer
   150 000000AF 5D                      	pop	rbp	; restore caller base pointer
   151 000000B0 C3                      	ret	; return from subroutine with result in RAX
   152                                  	
   153                                  	
   154                                  	
   155                                  ; END SUBROUTINE: fib
   156                                  ;--------------------------------------------------------
   157                                  
   158                                  main:
   159                                  
   160                                  ; keep looping until user quits
   161                                  loopnt	equ	$
   162 000000B1 E8(00000000)            	call	Crlf
   163                                  
   164 000000B6 48BA-                   	mov	rdx, prompt	; write user prompt
   164 000000B8 [3200000000000000] 
   165 000000C0 E8(00000000)            	call	WriteString
   166 000000C5 E8(00000000)            	call	Crlf
   167                                  
   168 000000CA 48BA-                   	mov	rdx, ipbuf	; address data buffer
   168 000000CC [6E00000000000000] 
   169 000000D4 B9FF000000              	mov	rcx, ipbufln	; limit data
   170 000000D9 E8(00000000)            	call	ReadString	; perform keyboard read
   171 000000DE 48BA-                   	mov	rdx, ipbuf	; address numeral input area
   171 000000E0 [6E00000000000000] 
   172 000000E8 4889C1                  	mov	rcx, rax	; numeral count
   173 000000EB E8(00000000)            	call	ParseInteger64	; parse signed binary from input, returned in RAX
   174 000000F0 4883F800                	cmp	rax, 0 ; return of 0 from RAX indicates invalid input
   175 000000F4 7460                    	je	invalid
   176 000000F6 7C77                    	jl	negnum	; causes infinite loop
   177 000000F8 4989C0                  	mov	r8, rax	; preserve original user input
   178                                  	; indenting for ease of reading
   179 000000FB 41BF01000000            	mov	r15, 1	; loop iterator variable
   180                                  	fibloop	equ	$
   181                                  		
   182 00000101 4157                    		push	r15	; fib(R15)
   183 00000103 E856FFFFFF              		call	fib
   184 00000108 4883C408                		add	rsp, 8*1; clear R15 from stack
   185                                  		; whaddaya know, fib() also returns RAX
   186 0000010C E8(00000000)            		call	WriteInt	; print fib(n)
   187 00000111 E8(00000000)            		call	Crlf
   188 00000116 4D39C7                  		cmp	r15, r8		; compare user input w/ loop iterator
   189 00000119 7405                    		je	goldrat		; if equal, leave loop
   190 0000011B 49FFC7                  		inc	r15		; else, increment iterator + continue
   191 0000011E EBE1                    		jmp	fibloop		; loop again
   192                                  	; once more for golden ratio
   193                                  goldrat	equ	$
   194 00000120 4150                    	push	r8
   195 00000122 E837FFFFFF              	call	fib
   196 00000127 4883C408                	add	rsp, 8*1; clear r8 from stack
   197 0000012B 4889C3                  	mov	rbx, rax
   198 0000012E 4150                    	push	r8
   199 00000130 E829FFFFFF              	call	fib
   200 00000135 4883C408                	add	rsp, 8*1
   201 00000139 50                      	push	rax
   202 0000013A 53                      	push 	rbx
   203 0000013B E8FBFEFFFF              	call	phi
   204 00000140 4883C410                	add	rsp, 8*2
   205                                  	; OK, for this I need to push an SSE register onto the stack
   206                                  	; It is twice the size of a normal register
   207                                  	; as such I cannot use push and pop
   208                                  	; I need to do it manually
   209 00000144 4883EC10                	sub	rsp, 8*2; subtract 16 bytes or 128 bits
   210 00000148 F30F7F0424              	movdqu	[rsp], xmm0
   211 0000014D E8AEFEFFFF              	call	fpcvt	; call floating point converter
   212                                  	; pop xmm0
   213 00000152 4883C410                	add	rsp, 8*2
   214                                  
   215                                  invalid	equ	$
   216 00000156 48BA-                   	mov	rdx, invmsg	; write invalid message
   216 00000158 [6D01000000000000] 
   217 00000160 E8(00000000)            	call	WriteString
   218 00000165 E8(00000000)            	call	Crlf
   219 0000016A E942FFFFFF              	jmp	loopnt		; loop back to beginning of subroutine
   220                                  
   221                                  negnum	equ	$
   222 0000016F 48BA-                   	mov	rdx, negmsg	; write negative numbers message
   222 00000171 [1500000000000000] 
   223 00000179 E8(00000000)            	call	WriteString
   224 0000017E E8(00000000)            	call	Crlf
   225 00000183 E929FFFFFF              	jmp	loopnt		; loop back to beginning of subroutine
   226                                  
   227                                  term	equ	$
   228 00000188 48BA-                   	mov	rdx, eopmsg	; address message
   228 0000018A [0000000000000000] 
   229 00000192 E8(00000000)            	call	WriteString
   230 00000197 E8(00000000)            	call	Crlf
   231 0000019C B83C0000004831FF0F-     	Exit
   231 000001A5 05                 
   232                                  
   233                                  
   234                                  
