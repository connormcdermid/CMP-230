     1                                  ; AUTHOR: Connor McDermid
     2                                  ; DATE: 2021-09-23
     3                                  ; 64-bit Lab 2 "numrep": 
     4                                  %include "Macros_CPsub64.inc"
     5                              <1> ;--------------------------- MACROS ------------------------------------------
     6                              <1> ; Change Log:
     7                              <1> ; 02-06-21 CP Rename ifndef for Exit from CPExit to Exit, update mShowRegister
     8                              <1> ;
     9                              <1> ;
    10                              <1> ;-----------------------------------------------------------------------------
    11                              <1> %ifndef MACRO_CPSUB64
    12                              <1> %define MACRO_CPSUB64
    13                              <1> 
    14                              <1> %define STDIN  0
    15                              <1> %define STDOUT 1
    16                              <1> %define STDERR 2
    17                              <1> 
    18                              <1> %define TAB 09h
    19                              <1> %define NL 0Ah
    20                              <1> 
    21                              <1> ; define the timespec structure used in nanosleep
    22                              <1> struc timespec
    23 00000000 ????????            <1>      tv_sec: resd 1
    24 00000004 ????????            <1>      tv_nsec: resd 1
    25                              <1> endstruc
    26                              <1> 
    27                              <1> 
    28                              <1> ; Synonym for NASM invoke
    29                              <1> %ifnmacro INVOKE
    30                              <1> %macro INVOKE 1-*.nolist
    31                              <1>      %rep %0 - 1
    32                              <1>      %rotate -1
    33                              <1>      push qword %1
    34                              <1>      %endrep
    35                              <1>      %rotate -1
    36                              <1>      call %1
    37                              <1>      add rsp, ( %0 - 1 ) * 8
    38                              <1> %endmacro
    39                              <1> %endif
    40                              <1> 
    41                              <1> 
    42                              <1> %ifnmacro mWrite
    43                              <1> ;------------------------------------------------------
    44                              <1> %macro mWrite 1.nolist
    45                              <1> ;
    46                              <1> ; Writes a string literal to standard output.
    47                              <1> ; Receives: a string enclosed in single or double 
    48                              <1> ;   quotes (null terminator not required).
    49                              <1> ;------------------------------------------------------
    50                              <1> segment .data
    51                              <1> 	%%string: db %1, 0
    52                              <1> segment .text
    53                              <1> 	push	rdx
    54                              <1> 	mov	rdx,%%string
    55                              <1>  	call	WriteString
    56                              <1>  	pop	rdx
    57                              <1> %endmacro
    58                              <1> %endif
    59                              <1> 
    60                              <1> 
    61                              <1> %ifnmacro mWriteSpace
    62                              <1> ;------------------------------------------------------
    63                              <1> %macro mWriteSpace 0-1.nolist 1
    64                              <1> ;
    65                              <1> ; Writes one or more spaces to standard output.
    66                              <1> ; Receives: an integer specifying the number of spaces.
    67                              <1> ;   If count is blank, a single space is written.
    68                              <1> ;------------------------------------------------------
    69                              <1> segment .data
    70                              <1> %%spaces: times %1 db ' '
    71                              <1> 	db 0
    72                              <1> segment .text
    73                              <1> 	push	rdx
    74                              <1> 	mov	rdx, %%spaces
    75                              <1> 	call	WriteString
    76                              <1> 	pop	rdx
    77                              <1> %endmacro
    78                              <1> %endif
    79                              <1> 
    80                              <1> 
    81                              <1> %ifnmacro mShowRegister
    82                              <1> ;---------------------------------------------------
    83                              <1> %macro mShowRegister 2.nolist
    84                              <1> ;
    85                              <1> ; Displays a 64-bit register name and its contents.
    86                              <1> ; Receives: the register string name, the register.
    87                              <1> ; Returns:  nothing
    88                              <1> ;---------------------------------------------------
    89                              <1> segment .data
    90                              <1> %%tempStr: db "  ", %1,": ",0
    91                              <1> 
    92                              <1> segment .text
    93                              <1> 	push	rax		; save reg	
    94                              <1> 	push	rdx 		; save reg
    95                              <1> 	mov	rdx, %%tempStr	; display the register name
    96                              <1> 	call	WriteString
    97                              <1> 	pop	rdx		; restore reg
    98                              <1> 	mov	rax, %2		; display the reg contents in hex
    99                              <1> 	call	WriteHex
   100                              <1> 	pop	rax             ; restore reg
   101                              <1> %endmacro
   102                              <1> %endif
   103                              <1> 
   104                              <1> 
   105                              <1> %ifnmacro ShowFlag
   106                              <1> ;---------------------------------------------------------------------
   107                              <1> %macro ShowFlag 2.nolist
   108                              <1> ;
   109                              <1> ; Helper macro.
   110                              <1> ; Display a single CPU flag value
   111                              <1> ; Directly accesses the eflags variable in Along32.asm
   112                              <1> ; (This macro cannot be placed in Macros.inc)
   113                              <1> ;---------------------------------------------------------------------
   114                              <1> segment .data
   115                              <1> %%flagStr: db "  ",%1, "="
   116                              <1> %%flagVal: db 0,0
   117                              <1> 
   118                              <1> segment .text
   119                              <1> 	push rax
   120                              <1> 	push rdx
   121                              <1> 	mov  rax, qword [eflags]	; retrieve the flags
   122                              <1> 	mov  byte [%%flagVal],'1'
   123                              <1> 	shr  rax, %2			; shift into carry flag
   124                              <1> 	jc   %%L1
   125                              <1> 	mov  byte [%%flagVal],'0'
   126                              <1> %%L1:
   127                              <1> 	mov  rdx, %%flagStr	; display flag name and value
   128                              <1> 	call WriteString
   129                              <1> 	pop  rdx
   130                              <1> 	pop  rax
   131                              <1> %endmacro
   132                              <1> %endif
   133                              <1> 
   134                              <1> 
   135                              <1> %ifnmacro ShowCC
   136                              <1> ;---------------------------------------------------------------------
   137                              <1> %macro ShowCC 2.nolist
   138                              <1> ;
   139                              <1> ; Helper macro.
   140                              <1> ; Display a single Condition Code Eflag name and value
   141                              <1> ; Directly accesses the eflags variable.
   142                              <1> ; 
   143                              <1> ;---------------------------------------------------------------------
   144                              <1> segment .data
   145                              <1> %%flagStr: db "  ",%1," : "    	; flag name plus = sign
   146                              <1> %%flagVal: db 0,0         	; flag value if 0 or 1, plus NULL
   147                              <1> 
   148                              <1> segment .text
   149                              <1> 	push rax  		; save reg
   150                              <1> 	push rdx		; save reg
   151                              <1> 	mov  rax, qword [eflags]	; retrieve the flags
   152                              <1> 	mov  byte [%%flagVal],'1'	; ON
   153                              <1> 	shr  rax, %2		; shift into carry flag
   154                              <1> 	jc   %%L1
   155                              <1> 	mov  byte [%%flagVal],'0'	; OFF
   156                              <1> %%L1:
   157                              <1> 	mov  rdx, %%flagStr	; display flag name and value
   158                              <1> 	call WriteString
   159                              <1> 	call Crlf		; line feed
   160                              <1> 	pop  rdx		; restore reg
   161                              <1> 	pop  rax		; restore reg
   162                              <1> %endmacro
   163                              <1> %endif
   164                              <1> 
   165                              <1> 
   166                              <1> 
   167                              <1> %ifnmacro CheckInit
   168                              <1> ;-------------------------------------------------------------
   169                              <1> %macro CheckInit 0.nolist
   170                              <1> ;
   171                              <1> ; Helper macro
   172                              <1> ; Check to see if the console handles have been initialized
   173                              <1> ; If not, initialize them now.
   174                              <1> ;-------------------------------------------------------------
   175                              <1> 	cmp byte [InitFlag],0
   176                              <1> 	jne %%exit
   177                              <1> 	mov byte [InitFlag],1
   178                              <1> 	call BufferFlush
   179                              <1> %%exit:
   180                              <1> %endmacro
   181                              <1> %endif
   182                              <1> 
   183                              <1> 
   184                              <1> %ifnmacro SaveRegs
   185                              <1> ;-------------------------------------------------------------
   186                              <1> %macro SaveRegs 0.nolist
   187                              <1> ;
   188                              <1> ; Convenience macro
   189                              <1> ; Save Registers
   190                              <1> ; PUSH the 16 general purpose regs to the stack.
   191                              <1> ;-------------------------------------------------------------
   192                              <1>        push rax
   193                              <1>        push rbx 
   194                              <1>        push rcx
   195                              <1>        push rdx
   196                              <1>        push rsi
   197                              <1>        push rdi
   198                              <1>        push rbp
   199                              <1>        push rsp
   200                              <1>        push r8 	
   201                              <1>        push r9  
   202                              <1>        push r10
   203                              <1>        push r11
   204                              <1>        push r12
   205                              <1>        push r13
   206                              <1>        push r14
   207                              <1>        push r15
   208                              <1> %%exit:
   209                              <1> %endmacro
   210                              <1> %endif
   211                              <1> 
   212                              <1> %ifnmacro RestoreRegs
   213                              <1> ;-------------------------------------------------------------
   214                              <1> %macro RestoreRegs 0.nolist
   215                              <1> ;
   216                              <1> ; Convenience macro
   217                              <1> ; Restore Registers
   218                              <1> ; POP the 16 general purpose regs from the stack.
   219                              <1> ;-------------------------------------------------------------
   220                              <1> 	pop r15
   221                              <1> 	pop r14
   222                              <1> 	pop r13
   223                              <1>      	pop r12
   224                              <1> 	pop r11 
   225                              <1> 	pop r10
   226                              <1>      	pop r9 
   227                              <1>      	pop r8 
   228                              <1> 	pop rsp
   229                              <1>       	pop rbp 
   230                              <1>       	pop rdi
   231                              <1>       	pop rsi
   232                              <1>       	pop rdx
   233                              <1>       	pop rcx 
   234                              <1>       	pop rbx
   235                              <1>       	pop rax
   236                              <1> %%exit:
   237                              <1> %endmacro
   238                              <1> %endif
   239                              <1> 
   240                              <1> ; Termination Macro
   241                              <1> ;-------------------------------------------------------------
   242                              <1> ;
   243                              <1> ; Convenience macro
   244                              <1> ; Exit to operating system under Linux.
   245                              <1> ;-------------------------------------------------------------
   246                              <1> %ifnmacro Exit
   247                              <1> %macro Exit 0.nolist  
   248                              <1>      mov rax, 60
   249                              <1>      xor rdi, rdi
   250                              <1>      syscall
   251                              <1> %%exit:
   252                              <1> %endmacro
   253                              <1> %endif
   254                              <1> 
   255                              <1> ; Termination Macro
   256                              <1> %ifnmacro CPexit
   257                              <1> ;-------------------------------------------------------------
   258                              <1> ;
   259                              <1> ; Convenience macro
   260                              <1> ; Exit to operating system under Linux.
   261                              <1> ;-------------------------------------------------------------
   262                              <1> %macro CPexit 0-1.nolist  
   263                              <1>      mov rax, 60
   264                              <1>      xor rdi, rdi
   265                              <1>      syscall
   266                              <1> %%exit:
   267                              <1> %endmacro
   268                              <1> %endif
   269                              <1> 
   270                              <1> %endif  ;End of Macro Definitions
     5                                  %include "CPsub64.inc"
     6                              <1> ; Last update: 2019/08/20
     7                              <1> 
     8                              <1> %ifndef CPSUB64
     9                              <1> %define CPSUB64
    10                              <1> 
    11                              <1> ; ------------------------------------------
    12                              <1> ; function prototypes
    13                              <1> ; ------------------------------------------
    14                              <1> extern Clearscr
    15                              <1> extern CloseFile
    16                              <1> extern Crlf
    17                              <1> extern ClearBuffer
    18                              <1> extern Delay
    19                              <1> extern DumpMem
    20                              <1> extern DumpCC
    21                              <1> extern DumpEflags
    22                              <1> extern DumpRegs
    23                              <1> extern IsDigit
    24                              <1> extern Mvcl
    25                              <1> extern FileOpen
    26                              <1> extern FileClose
    27                              <1> extern FileRead
    28                              <1> extern FileWrite
    29                              <1> extern ParseDecimal32
    30                              <1> extern ParseInteger32
    31                              <1> extern ParseDecimal64
    32                              <1> extern ParseInteger64
    33                              <1> extern ReadChar
    34                              <1> extern ReadDec
    35                              <1> extern ReadHex
    36                              <1> extern ReadInt
    37                              <1> extern ReadKey
    38                              <1> extern ReadString
    39                              <1> extern ReadStr
    40                              <1> extern Str_compare
    41                              <1> extern Str_copy
    42                              <1> extern Str_length
    43                              <1> extern StrLength
    44                              <1> extern Str_trim
    45                              <1> extern Str_ucase
    46                              <1> extern WriteBin
    47                              <1> extern WriteBinB
    48                              <1> extern WriteChar
    49                              <1> extern WriteDec
    50                              <1> extern WriteHex
    51                              <1> extern WriteHexDbl
    52                              <1> extern WriteHexB
    53                              <1> extern WriteInt
    54                              <1> extern WriteString
    55                              <1> ; ------------------------------------------
    56                              <1> 
    57                              <1> %endif
     6                                  
     7                                  global	main			; global entry point for ld
     8                                  
     9                                  section	.text
    10                                  ; attempting to write my own working procedure -- reverse engineered from provided procedure lib
    11                                  tab:	; prints a tab character -- double checked mnemonics list to ensure there's no mnemonic named "tab"
    12 00000000 505351525657555441-     	SaveRegs		; don't clobber registers
    12 00000009 504151415241534154-
    12 00000012 415541564157       
    13                                  
    14 00000018 48BA-                   	mov	rdx, tabchar
    14 0000001A [0000000000000000] 
    15 00000022 E8(00000000)            	call	WriteString
    16                                  
    17 00000027 415F415E415D415C41-     	RestoreRegs
    17 00000030 5B415A415941585C5D-
    17 00000039 5F5E5A595B58       
    18 0000003F C3                      	ret
    19                                  
    20                                  writeNumbers:			; takes the number in RAX and prints it in decimal, hex, and binary
    21 00000040 505351525657555441-     	SaveRegs		; don't clobber registers
    21 00000049 504151415241534154-
    21 00000052 415541564157       
    22                                  
    23 00000058 E8(00000000)            	call	Crlf
    24 0000005D E89EFFFFFF              	call	tab
    25 00000062 48BA-                   	mov	rdx, decmsg	; write decmsg
    25 00000064 [9700000000000000] 
    26 0000006C E8(00000000)            	call	WriteString
    27 00000071 E8(00000000)            	call	Crlf
    28                                  	
    29 00000076 E885FFFFFF              	call	tab
    30 0000007B E880FFFFFF              	call	tab
    31 00000080 E8(00000000)            	call	WriteInt	; write decimal representation
    32 00000085 E8(00000000)            	call	Crlf
    33                                  
    34 0000008A E871FFFFFF              	call	tab
    35 0000008F 48BA-                   	mov	rdx, hexmsg	; write hexmsg
    35 00000091 [A100000000000000] 
    36 00000099 E8(00000000)            	call	WriteString	
    37 0000009E E8(00000000)            	call	Crlf
    38                                  
    39 000000A3 E858FFFFFF              	call	tab
    40 000000A8 E853FFFFFF              	call	tab
    41 000000AD E8(00000000)            	call	WriteHex	; write hexadecimal representation
    42 000000B2 E8(00000000)            	call	Crlf
    43                                  
    44 000000B7 E844FFFFFF              	call	tab
    45 000000BC 48BA-                   	mov	rdx, binmsg	; write binmsg
    45 000000BE [AF00000000000000] 
    46 000000C6 E8(00000000)            	call	WriteString
    47 000000CB E8(00000000)            	call	Crlf
    48                                  	
    49 000000D0 E82BFFFFFF              	call	tab
    50 000000D5 E826FFFFFF              	call	tab
    51 000000DA E8(00000000)            	call	WriteBin	; write binary representation
    52 000000DF E8(00000000)            	call	Crlf
    53                                  
    54 000000E4 415F415E415D415C41-     	RestoreRegs
    54 000000ED 5B415A415941585C5D-
    54 000000F6 5F5E5A595B58       
    55                                  	
    56 000000FC C3                      	ret			; MUST BE INCLUDED otherwise program continues at top of next procedure
    57                                  				; in this case, causes infinite loop
    58                                  
    59                                  main:
    60 000000FD 41B804000000            	mov	r8, 4		; r8 will be loop iterator variable
    61                                  
    62                                  loopnt	equ	$		; top of loop
    63 00000103 E8(00000000)            	call	Crlf
    64 00000108 48BA-                   	mov	rdx, prompt1	; prompt user for number 1
    64 0000010A [0500000000000000] 
    65 00000112 E8(00000000)            	call	WriteString
    66                                  	
    67 00000117 48BA-                   	mov 	rdx, ipbuffer	; address the data buffer
    67 00000119 [DE00000000000000] 
    68 00000121 B9FF000000              	mov	rcx, ipbuflen	; limit data
    69 00000126 E8(00000000)            	call	ReadString	; perform a keyboard read
    70 0000012B 48BA-                   	mov	rdx, ipbuffer	; address numeral input area
    70 0000012D [DE00000000000000] 
    71 00000135 4889C1                  	mov	rcx, rax	; numeral count
    72 00000138 E8(00000000)            	call	ParseInteger64	; convert to signed binary
    73 0000013D 48890425[DD010000]      	mov	[num1], rax	; store signed bin
    74                                  
    75 00000145 E8(00000000)            	call	Crlf
    76 0000014A 48BA-                   	mov	rdx, prompt2	; prompt user for number 2
    76 0000014C [4400000000000000] 
    77 00000154 E8(00000000)            	call	WriteString
    78                                  	
    79 00000159 48BA-                   	mov 	rdx, ipbuffer	; address the data buffer
    79 0000015B [DE00000000000000] 
    80 00000163 B9FF000000              	mov	rcx, ipbuflen	; limit data
    81 00000168 E8(00000000)            	call	ReadString	; perform a keyboard read
    82 0000016D 48BA-                   	mov	rdx, ipbuffer	; address numeral input area
    82 0000016F [DE00000000000000] 
    83 00000177 4889C1                  	mov	rcx, rax	; numeral count
    84 0000017A E8(00000000)            	call	ParseInteger64	; convert to signed binary
    85 0000017F 48890425[E5010000]      	mov	[num2], rax	; store signed bin
    86                                  
    87 00000187 E8(00000000)            	call	Crlf
    88                                  
    89 0000018C 48BA-                   	mov	rdx, n1msg
    89 0000018E [7800000000000000] 
    90 00000196 E8(00000000)            	call	WriteString
    91 0000019B E8(00000000)            	call	Crlf
    92 000001A0 488B0425[DD010000]      	mov	rax, [num1]
    93 000001A8 E893FEFFFF              	call	writeNumbers	; call to writeNumbers to print all representations
    94 000001AD E8(00000000)            	call	Crlf
    95                                  
    96 000001B2 48BA-                   	mov	rdx, n2msg
    96 000001B4 [8700000000000000] 
    97 000001BC E8(00000000)            	call	WriteString
    98 000001C1 E8(00000000)            	call	Crlf
    99 000001C6 488B0425[E5010000]      	mov	rax, [num2]
   100 000001CE E86DFEFFFF              	call	writeNumbers
   101 000001D3 E8(00000000)            	call	Crlf
   102                                  
   103                                  	; now, print OR, AND, and XOR
   104                                  	
   105 000001D8 488B0425[DD010000]      	mov	rax, [num1]
   106 000001E0 E8(00000000)            	call	WriteInt
   107 000001E5 48BA-                   	mov	rdx, ormsg
   107 000001E7 [B800000000000000] 
   108 000001EF E8(00000000)            	call	WriteString
   109 000001F4 488B0425[E5010000]      	mov	rax, [num2]
   110 000001FC E8(00000000)            	call	WriteInt
   111 00000201 E8(00000000)            	call	Crlf
   112                                  
   113 00000206 488B0425[DD010000]      	mov	rax, [num1]
   114 0000020E 488B1C25[E5010000]      	mov	rbx, [num2]
   115 00000216 4809D8                  	or	rax, rbx	; num1 OR num2, result in RAX
   116 00000219 E822FEFFFF              	call	writeNumbers
   117 0000021E E8(00000000)            	call	Crlf
   118                                  
   119                                  
   120 00000223 488B0425[DD010000]      	mov	rax, [num1]
   121 0000022B E8(00000000)            	call	WriteInt
   122 00000230 48BA-                   	mov	rdx, andmsg
   122 00000232 [BD00000000000000] 
   123 0000023A E8(00000000)            	call	WriteString
   124 0000023F 488B0425[E5010000]      	mov	rax, [num2]
   125 00000247 E8(00000000)            	call	WriteInt
   126 0000024C E8(00000000)            	call	Crlf
   127                                  
   128 00000251 488B0425[DD010000]      	mov	rax, [num1]
   129 00000259 488B1C25[E5010000]      	mov	rbx, [num2]
   130 00000261 4821D8                  	and	rax, rbx	; num1 AND num2, result in RAX
   131 00000264 E8D7FDFFFF              	call	writeNumbers
   132 00000269 E8(00000000)            	call	Crlf
   133                                  
   134 0000026E 488B0425[DD010000]      	mov	rax, [num1]
   135 00000276 E8(00000000)            	call	WriteInt
   136 0000027B 48BA-                   	mov	rdx, xormsg
   136 0000027D [C300000000000000] 
   137 00000285 E8(00000000)            	call	WriteString
   138 0000028A 488B0425[E5010000]      	mov	rax, [num2]
   139 00000292 E8(00000000)            	call	WriteInt
   140 00000297 E8(00000000)            	call	Crlf
   141                                  
   142 0000029C 488B0425[DD010000]      	mov	rax, [num1]
   143 000002A4 488B1C25[E5010000]      	mov	rbx, [num2]
   144 000002AC 4831D8                  	xor	rax, rbx	; num1 XOR num2, result in RAX
   145 000002AF E88CFDFFFF              	call	writeNumbers
   146 000002B4 E8(00000000)            	call	Crlf
   147 000002B9 49FFC8                  	dec	r8
   148                                  
   149 000002BC 0F8541FEFFFF            	jnz	loopnt		; if r8 is not 0, loop
   150                                  
   151                                  term	equ	$
   152 000002C2 48BA-                   	mov	rdx, eopmsg
   152 000002C4 [C900000000000000] 
   153 000002CC E8(00000000)            	call	WriteString
   154 000002D1 E8(00000000)            	call	Crlf
   155 000002D6 B83C0000004831FF0F-     	Exit
   155 000002DF 05                 
   156                                  section .data
   157                                  
   158 00000000 2020202000              tabchar	db	20h,20h,20h,20h,00h	; For use in formatting output: looks really ugly without it
   159 00000005 506C6561736520656E-     prompt1	db 	"Please enter a signed integer between 2^63 - 1 and -2^63 - 1: ",00h	; First prompt & NULL
   159 0000000E 746572206120736967-
   159 00000017 6E656420696E746567-
   159 00000020 657220626574776565-
   159 00000029 6E20325E3633202D20-
   159 00000032 3120616E64202D325E-
   159 0000003B 3633202D20313A2000 
   160 00000044 506C6561736520656E-     prompt2	db	"Please enter a second number with the same limits: ",00h	; second prompt & NULL
   160 0000004D 746572206120736563-
   160 00000056 6F6E64206E756D6265-
   160 0000005F 722077697468207468-
   160 00000068 652073616D65206C69-
   160 00000071 6D6974733A2000     
   161 00000078 4649525354204E554D-     n1msg	db	"FIRST NUMBER: ",00h
   161 00000081 4245523A2000       
   162 00000087 5345434F4E44204E55-     n2msg	db	"SECOND NUMBER: ",00h
   162 00000090 4D4245523A2000     
   163 00000097 444543494D414C3A20-     decmsg	db	"DECIMAL: ",00h
   163 000000A0 00                 
   164 000000A1 48455841444543494D-     hexmsg	db	"HEXADECIMAL: ",00h
   164 000000AA 414C3A2000         
   165 000000AF 42494E4152593A2000      binmsg	db	"BINARY: ",00h
   166 000000B8 204F522000              ormsg 	db	" OR ",00h
   167 000000BD 20414E442000            andmsg	db	" AND ",00h
   168 000000C3 20584F522000            xormsg	db	" XOR ",00h
   169 000000C9 50726F6772616D2074-     eopmsg	db	"Program terminating.",00h
   169 000000D2 65726D696E6174696E-
   169 000000DB 672E00             
   170 000000DE 20<rep FFh>             ipbuffer times 	255 db 20h			; define buffer of spaces
   171                                  ipbuflen equ	$-ipbuffer
   172 000001DD 0000000000000000        num1	dq	00h	; first number
   173 000001E5 0000000000000000        num2	dq	00h	; second number
