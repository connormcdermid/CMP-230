     1                                  ; AUTHOR: Connor McDermid
     2                                  ; DATE: 2021-09-23
     3                                  ; 64-bit Lab 2 "arithmetic": 
     4                                  %include "Macros_CPsub64.inc"
     5                              <1> ;--------------------------- MACROS ------------------------------------------
     6                              <1> ; Change Log:
     7                              <1> ; 02-06-21 CP Rename ifndef for Exit from CPExit to Exit, update mShowRegister
     8                              <1> ;
     9                              <1> ;
    10                              <1> ;-----------------------------------------------------------------------------
    11                              <1> %ifndef MACRO_CPSUB64
    12                              <1> %define MACRO_CPSUB64
    13                              <1> 
    14                              <1> %define STDIN  0
    15                              <1> %define STDOUT 1
    16                              <1> %define STDERR 2
    17                              <1> 
    18                              <1> %define TAB 09h
    19                              <1> %define NL 0Ah
    20                              <1> 
    21                              <1> ; define the timespec structure used in nanosleep
    22                              <1> struc timespec
    23 00000000 ????????            <1>      tv_sec: resd 1
    24 00000004 ????????            <1>      tv_nsec: resd 1
    25                              <1> endstruc
    26                              <1> 
    27                              <1> 
    28                              <1> ; Synonym for NASM invoke
    29                              <1> %ifnmacro INVOKE
    30                              <1> %macro INVOKE 1-*.nolist
    31                              <1>      %rep %0 - 1
    32                              <1>      %rotate -1
    33                              <1>      push qword %1
    34                              <1>      %endrep
    35                              <1>      %rotate -1
    36                              <1>      call %1
    37                              <1>      add rsp, ( %0 - 1 ) * 8
    38                              <1> %endmacro
    39                              <1> %endif
    40                              <1> 
    41                              <1> 
    42                              <1> %ifnmacro mWrite
    43                              <1> ;------------------------------------------------------
    44                              <1> %macro mWrite 1.nolist
    45                              <1> ;
    46                              <1> ; Writes a string literal to standard output.
    47                              <1> ; Receives: a string enclosed in single or double 
    48                              <1> ;   quotes (null terminator not required).
    49                              <1> ;------------------------------------------------------
    50                              <1> segment .data
    51                              <1> 	%%string: db %1, 0
    52                              <1> segment .text
    53                              <1> 	push	rdx
    54                              <1> 	mov	rdx,%%string
    55                              <1>  	call	WriteString
    56                              <1>  	pop	rdx
    57                              <1> %endmacro
    58                              <1> %endif
    59                              <1> 
    60                              <1> 
    61                              <1> %ifnmacro mWriteSpace
    62                              <1> ;------------------------------------------------------
    63                              <1> %macro mWriteSpace 0-1.nolist 1
    64                              <1> ;
    65                              <1> ; Writes one or more spaces to standard output.
    66                              <1> ; Receives: an integer specifying the number of spaces.
    67                              <1> ;   If count is blank, a single space is written.
    68                              <1> ;------------------------------------------------------
    69                              <1> segment .data
    70                              <1> %%spaces: times %1 db ' '
    71                              <1> 	db 0
    72                              <1> segment .text
    73                              <1> 	push	rdx
    74                              <1> 	mov	rdx, %%spaces
    75                              <1> 	call	WriteString
    76                              <1> 	pop	rdx
    77                              <1> %endmacro
    78                              <1> %endif
    79                              <1> 
    80                              <1> 
    81                              <1> %ifnmacro mShowRegister
    82                              <1> ;---------------------------------------------------
    83                              <1> %macro mShowRegister 2.nolist
    84                              <1> ;
    85                              <1> ; Displays a 64-bit register name and its contents.
    86                              <1> ; Receives: the register string name, the register.
    87                              <1> ; Returns:  nothing
    88                              <1> ;---------------------------------------------------
    89                              <1> segment .data
    90                              <1> %%tempStr: db "  ", %1,": ",0
    91                              <1> 
    92                              <1> segment .text
    93                              <1> 	push	rax		; save reg	
    94                              <1> 	push	rdx 		; save reg
    95                              <1> 	mov	rdx, %%tempStr	; display the register name
    96                              <1> 	call	WriteString
    97                              <1> 	pop	rdx		; restore reg
    98                              <1> 	mov	rax, %2		; display the reg contents in hex
    99                              <1> 	call	WriteHex
   100                              <1> 	pop	rax             ; restore reg
   101                              <1> %endmacro
   102                              <1> %endif
   103                              <1> 
   104                              <1> 
   105                              <1> %ifnmacro ShowFlag
   106                              <1> ;---------------------------------------------------------------------
   107                              <1> %macro ShowFlag 2.nolist
   108                              <1> ;
   109                              <1> ; Helper macro.
   110                              <1> ; Display a single CPU flag value
   111                              <1> ; Directly accesses the eflags variable in Along32.asm
   112                              <1> ; (This macro cannot be placed in Macros.inc)
   113                              <1> ;---------------------------------------------------------------------
   114                              <1> segment .data
   115                              <1> %%flagStr: db "  ",%1, "="
   116                              <1> %%flagVal: db 0,0
   117                              <1> 
   118                              <1> segment .text
   119                              <1> 	push rax
   120                              <1> 	push rdx
   121                              <1> 	mov  rax, qword [eflags]	; retrieve the flags
   122                              <1> 	mov  byte [%%flagVal],'1'
   123                              <1> 	shr  rax, %2			; shift into carry flag
   124                              <1> 	jc   %%L1
   125                              <1> 	mov  byte [%%flagVal],'0'
   126                              <1> %%L1:
   127                              <1> 	mov  rdx, %%flagStr	; display flag name and value
   128                              <1> 	call WriteString
   129                              <1> 	pop  rdx
   130                              <1> 	pop  rax
   131                              <1> %endmacro
   132                              <1> %endif
   133                              <1> 
   134                              <1> 
   135                              <1> %ifnmacro ShowCC
   136                              <1> ;---------------------------------------------------------------------
   137                              <1> %macro ShowCC 2.nolist
   138                              <1> ;
   139                              <1> ; Helper macro.
   140                              <1> ; Display a single Condition Code Eflag name and value
   141                              <1> ; Directly accesses the eflags variable.
   142                              <1> ; 
   143                              <1> ;---------------------------------------------------------------------
   144                              <1> segment .data
   145                              <1> %%flagStr: db "  ",%1," : "    	; flag name plus = sign
   146                              <1> %%flagVal: db 0,0         	; flag value if 0 or 1, plus NULL
   147                              <1> 
   148                              <1> segment .text
   149                              <1> 	push rax  		; save reg
   150                              <1> 	push rdx		; save reg
   151                              <1> 	mov  rax, qword [eflags]	; retrieve the flags
   152                              <1> 	mov  byte [%%flagVal],'1'	; ON
   153                              <1> 	shr  rax, %2		; shift into carry flag
   154                              <1> 	jc   %%L1
   155                              <1> 	mov  byte [%%flagVal],'0'	; OFF
   156                              <1> %%L1:
   157                              <1> 	mov  rdx, %%flagStr	; display flag name and value
   158                              <1> 	call WriteString
   159                              <1> 	call Crlf		; line feed
   160                              <1> 	pop  rdx		; restore reg
   161                              <1> 	pop  rax		; restore reg
   162                              <1> %endmacro
   163                              <1> %endif
   164                              <1> 
   165                              <1> 
   166                              <1> 
   167                              <1> %ifnmacro CheckInit
   168                              <1> ;-------------------------------------------------------------
   169                              <1> %macro CheckInit 0.nolist
   170                              <1> ;
   171                              <1> ; Helper macro
   172                              <1> ; Check to see if the console handles have been initialized
   173                              <1> ; If not, initialize them now.
   174                              <1> ;-------------------------------------------------------------
   175                              <1> 	cmp byte [InitFlag],0
   176                              <1> 	jne %%exit
   177                              <1> 	mov byte [InitFlag],1
   178                              <1> 	call BufferFlush
   179                              <1> %%exit:
   180                              <1> %endmacro
   181                              <1> %endif
   182                              <1> 
   183                              <1> 
   184                              <1> %ifnmacro SaveRegs
   185                              <1> ;-------------------------------------------------------------
   186                              <1> %macro SaveRegs 0.nolist
   187                              <1> ;
   188                              <1> ; Convenience macro
   189                              <1> ; Save Registers
   190                              <1> ; PUSH the 16 general purpose regs to the stack.
   191                              <1> ;-------------------------------------------------------------
   192                              <1>        push rax
   193                              <1>        push rbx 
   194                              <1>        push rcx
   195                              <1>        push rdx
   196                              <1>        push rsi
   197                              <1>        push rdi
   198                              <1>        push rbp
   199                              <1>        push rsp
   200                              <1>        push r8 	
   201                              <1>        push r9  
   202                              <1>        push r10
   203                              <1>        push r11
   204                              <1>        push r12
   205                              <1>        push r13
   206                              <1>        push r14
   207                              <1>        push r15
   208                              <1> %%exit:
   209                              <1> %endmacro
   210                              <1> %endif
   211                              <1> 
   212                              <1> %ifnmacro RestoreRegs
   213                              <1> ;-------------------------------------------------------------
   214                              <1> %macro RestoreRegs 0.nolist
   215                              <1> ;
   216                              <1> ; Convenience macro
   217                              <1> ; Restore Registers
   218                              <1> ; POP the 16 general purpose regs from the stack.
   219                              <1> ;-------------------------------------------------------------
   220                              <1> 	pop r15
   221                              <1> 	pop r14
   222                              <1> 	pop r13
   223                              <1>      	pop r12
   224                              <1> 	pop r11 
   225                              <1> 	pop r10
   226                              <1>      	pop r9 
   227                              <1>      	pop r8 
   228                              <1> 	pop rsp
   229                              <1>       	pop rbp 
   230                              <1>       	pop rdi
   231                              <1>       	pop rsi
   232                              <1>       	pop rdx
   233                              <1>       	pop rcx 
   234                              <1>       	pop rbx
   235                              <1>       	pop rax
   236                              <1> %%exit:
   237                              <1> %endmacro
   238                              <1> %endif
   239                              <1> 
   240                              <1> ; Termination Macro
   241                              <1> ;-------------------------------------------------------------
   242                              <1> ;
   243                              <1> ; Convenience macro
   244                              <1> ; Exit to operating system under Linux.
   245                              <1> ;-------------------------------------------------------------
   246                              <1> %ifnmacro Exit
   247                              <1> %macro Exit 0.nolist  
   248                              <1>      mov rax, 60
   249                              <1>      xor rdi, rdi
   250                              <1>      syscall
   251                              <1> %%exit:
   252                              <1> %endmacro
   253                              <1> %endif
   254                              <1> 
   255                              <1> ; Termination Macro
   256                              <1> %ifnmacro CPexit
   257                              <1> ;-------------------------------------------------------------
   258                              <1> ;
   259                              <1> ; Convenience macro
   260                              <1> ; Exit to operating system under Linux.
   261                              <1> ;-------------------------------------------------------------
   262                              <1> %macro CPexit 0-1.nolist  
   263                              <1>      mov rax, 60
   264                              <1>      xor rdi, rdi
   265                              <1>      syscall
   266                              <1> %%exit:
   267                              <1> %endmacro
   268                              <1> %endif
   269                              <1> 
   270                              <1> %endif  ;End of Macro Definitions
     5                                  %include "CPsub64.inc"
     6                              <1> ; Last update: 2019/08/20
     7                              <1> 
     8                              <1> %ifndef CPSUB64
     9                              <1> %define CPSUB64
    10                              <1> 
    11                              <1> ; ------------------------------------------
    12                              <1> ; function prototypes
    13                              <1> ; ------------------------------------------
    14                              <1> extern Clearscr
    15                              <1> extern CloseFile
    16                              <1> extern Crlf
    17                              <1> extern ClearBuffer
    18                              <1> extern Delay
    19                              <1> extern DumpMem
    20                              <1> extern DumpCC
    21                              <1> extern DumpEflags
    22                              <1> extern DumpRegs
    23                              <1> extern IsDigit
    24                              <1> extern Mvcl
    25                              <1> extern FileOpen
    26                              <1> extern FileClose
    27                              <1> extern FileRead
    28                              <1> extern FileWrite
    29                              <1> extern ParseDecimal32
    30                              <1> extern ParseInteger32
    31                              <1> extern ParseDecimal64
    32                              <1> extern ParseInteger64
    33                              <1> extern ReadChar
    34                              <1> extern ReadDec
    35                              <1> extern ReadHex
    36                              <1> extern ReadInt
    37                              <1> extern ReadKey
    38                              <1> extern ReadString
    39                              <1> extern ReadStr
    40                              <1> extern Str_compare
    41                              <1> extern Str_copy
    42                              <1> extern Str_length
    43                              <1> extern StrLength
    44                              <1> extern Str_trim
    45                              <1> extern Str_ucase
    46                              <1> extern WriteBin
    47                              <1> extern WriteBinB
    48                              <1> extern WriteChar
    49                              <1> extern WriteDec
    50                              <1> extern WriteHex
    51                              <1> extern WriteHexDbl
    52                              <1> extern WriteHexB
    53                              <1> extern WriteInt
    54                              <1> extern WriteString
    55                              <1> ; ------------------------------------------
    56                              <1> 
    57                              <1> %endif
     6                                  
     7                                  global	main			; global entry point for ld
     8                                  
     9                                  section	.text
    10                                  ; attempting to write my own working procedure -- reverse engineered from provided procedure lib
    11                                  tab:	; prints a tab character -- double checked mnemonics list to ensure there's no mnemonic named "tab"
    12 00000000 505351525657555441-     	SaveRegs		; don't clobber registers
    12 00000009 504151415241534154-
    12 00000012 415541564157       
    13                                  
    14 00000018 48BA-                   	mov	rdx, tabchar
    14 0000001A [0000000000000000] 
    15 00000022 E8(00000000)            	call	WriteString
    16                                  
    17 00000027 415F415E415D415C41-     	RestoreRegs
    17 00000030 5B415A415941585C5D-
    17 00000039 5F5E5A595B58       
    18 0000003F C3                      	ret
    19                                  
    20                                  
    21                                  main:
    22 00000040 41B804000000            	mov	r8, 4		; r8 will be loop iterator variable
    23                                  
    24 00000046 E8(00000000)            	call	Crlf
    25 0000004B 48BA-                   	mov	rdx, prompt1	; prompt user for number 1
    25 0000004D [0500000000000000] 
    26 00000055 E8(00000000)            	call	WriteString
    27                                  	
    28 0000005A 48BA-                   	mov 	rdx, ipbuffer	; address the data buffer
    28 0000005C [C600000000000000] 
    29 00000064 B9FF000000              	mov	rcx, ipbuflen	; limit data
    30 00000069 E8(00000000)            	call	ReadString	; perform a keyboard read
    31 0000006E 48BA-                   	mov	rdx, ipbuffer	; address numeral input area
    31 00000070 [C600000000000000] 
    32 00000078 4889C1                  	mov	rcx, rax	; numeral count
    33 0000007B E8(00000000)            	call	ParseInteger64	; convert to signed binary
    34 00000080 48890425[62000000]      	mov	[num1], rax	; store signed bin
    35                                  
    36 00000088 E8(00000000)            	call	Crlf
    37 0000008D 48BA-                   	mov	rdx, prompt2	; prompt user for operator
    37 0000008F [2500000000000000] 
    38 00000097 E8(00000000)            	call	WriteString
    39                                  	
    40 0000009C 48BA-                   	mov	rdx, ipbuffer
    40 0000009E [C600000000000000] 
    41 000000A6 B9FF000000              	mov	rcx, ipbuflen
    42 000000AB E8(00000000)            	call	ReadString
    43                                  	
    44 000000B0 8A1425[C6000000]        	mov	dl, [ipbuffer]	; store only the first byte of rdx
    45 000000B7 881425[72000000]        	mov	[oper], dl	; store *that* in memory
    46                                  	
    47                                  
    48 000000BE E8(00000000)            	call	Crlf
    49 000000C3 48BA-                   	mov	rdx, prompt3	; prompt user for number 2
    49 000000C5 [4100000000000000] 
    50 000000CD E8(00000000)            	call	WriteString
    51                                  	
    52 000000D2 48BA-                   	mov 	rdx, ipbuffer	; address the data buffer
    52 000000D4 [C600000000000000] 
    53 000000DC B9FF000000              	mov	rcx, ipbuflen	; limit data
    54 000000E1 E8(00000000)            	call	ReadString	; perform a keyboard read
    55 000000E6 48BA-                   	mov	rdx, ipbuffer	; address numeral input area
    55 000000E8 [C600000000000000] 
    56 000000F0 4889C1                  	mov	rcx, rax	; numeral count
    57 000000F3 E8(00000000)            	call	ParseInteger64	; convert to signed binary
    58 000000F8 48890425[6A000000]      	mov	[num2], rax	; store signed bin
    59                                  
    60 00000100 E8(00000000)            	call	Crlf
    61                                  	
    62 00000105 488B0425[62000000]      	mov	rax, [num1]	; load operand 1
    63 0000010D 488B1C25[6A000000]      	mov	rbx, [num2]	; load operand 2
    64 00000115 8A1425[72000000]        	mov	dl, [oper]	; load operator
    65                                  
    66 0000011C 80FA2B                  	cmp	dl, "+"
    67 0000011F 0F848A000000            	je	myAdd
    68 00000125 80FA2D                  	cmp	dl, "-"
    69 00000128 0F849F000000            	je	mySub
    70 0000012E 80FA2A                  	cmp	dl, "*"
    71 00000131 0F84B4000000            	je	myMult
    72 00000137 80FA2F                  	cmp	dl, "/"
    73 0000013A 0F84D5000000            	je	myDiv
    74 00000140 EB54                    	jmp	err		; default, invalid operator
    75                                  
    76                                  postres	equ	$
    77 00000142 48BA-                   	mov	rdx, resmsg	; post resmsg
    77 00000144 [7C00000000000000] 
    78 0000014C E8(00000000)            	call	WriteString
    79 00000151 488B0425[73000000]      	mov	rax, [result]	; load register with result
    80 00000159 E8(00000000)            	call	WriteInt
    81 0000015E E8(00000000)            	call	Crlf
    82 00000163 488B0C25[7B000000]      	mov	rcx, [rem]
    83 0000016B 4883F900                	cmp	rcx, 0
    84 0000016F 0F84BF000000            	jz	term		; if no remainder, jump to end
    85 00000175 48BA-                   	mov	rdx, remmsg	; if remainder, print it
    85 00000177 [8C00000000000000] 
    86 0000017F E8(00000000)            	call	WriteString
    87 00000184 4889C8                  	mov	rax, rcx	; remainder's already in rcx
    88 00000187 E8(00000000)            	call	WriteInt
    89 0000018C E8(00000000)            	call	Crlf
    90 00000191 E99E000000              	jmp	term
    91                                  
    92                                  err	equ	$
    93 00000196 48BA-                   	mov	rdx, errmsg	; print error message
    93 00000198 [9F00000000000000] 
    94 000001A0 E8(00000000)            	call	WriteString
    95 000001A5 E8(00000000)            	call	Crlf
    96 000001AA E985000000              	jmp	term		; terminate program
    97                                  
    98                                  myAdd	equ	$
    99 000001AF 4801D8                  	add	rax, rbx	; add loaded registers
   100 000001B2 48890425[73000000]      	mov	[result], rax	; store sum
   101 000001BA 41BA00000000            	mov	r10, 0
   102 000001C0 4C891425[7B000000]      	mov	[rem], r10	; make sure remainder is 0
   103 000001C8 E975FFFFFF              	jmp	postres
   104                                  
   105                                  mySub	equ	$
   106 000001CD 4829D8                  	sub	rax, rbx	; add loaded registers
   107 000001D0 48890425[73000000]      	mov	[result], rax	; store sum
   108 000001D8 41BA00000000            	mov	r10, 0
   109 000001DE 4C891425[7B000000]      	mov	[rem], r10	; make sure remainder is 0
   110 000001E6 E957FFFFFF              	jmp	postres
   111                                  
   112                                  myMult	equ	$	; outputs in RDX:RAX
   113 000001EB 4899                    	cqo	; perpetuate RAX into RDX
   114 000001ED E8(00000000)            	call	DumpRegs
   115 000001F2 48F7EB                  	imul	rbx	; rax, rbx already loaded with operands
   116                                  ;	mov	[multbuf], rdx
   117 000001F5 48890425[73000000]      	mov	[result], rax
   118                                  	;	add high-order bits 
   119 000001FD 41BA00000000            	mov	r10, 0
   120 00000203 4C891425[7B000000]      	mov	[rem], r10
   121 0000020B E8(00000000)            	call	DumpRegs
   122 00000210 E92DFFFFFF              	jmp	postres
   123                                  
   124                                  myDiv	equ	$
   125 00000215 4899                    	cqo	; perpetuate RAX into RDX
   126 00000217 E8(00000000)            	call	DumpRegs
   127 0000021C 48F7FB                  	idiv	rbx	; RAX, RBX already loaded with operands
   128 0000021F 48891425[7B000000]      	mov	[rem], rdx
   129 00000227 48890425[73000000]      	mov	[result], rax
   130 0000022F E90EFFFFFF              	jmp	postres
   131                                  
   132                                  term	equ	$
   133 00000234 48BA-                   	mov	rdx, eopmsg
   133 00000236 [B100000000000000] 
   134 0000023E E8(00000000)            	call	WriteString
   135 00000243 E8(00000000)            	call	Crlf
   136 00000248 B83C0000004831FF0F-     	Exit
   136 00000251 05                 
   137                                  
   138                                  section .data
   139                                  
   140 00000000 2020202000              tabchar	db	20h,20h,20h,20h,00h	; For use in formatting output: looks really ugly without it
   141 00000005 506C6561736520656E-     prompt1	db 	"Please enter the first number: ",00h	; First prompt & NULL
   141 0000000E 746572207468652066-
   141 00000017 69727374206E756D62-
   141 00000020 65723A2000         
   142 00000025 506C6561736520656E-     prompt2	db	"Please enter the operator: ",00h	; second prompt & NULL
   142 0000002E 74657220746865206F-
   142 00000037 70657261746F723A20-
   142 00000040 00                 
   143 00000041 506C6561736520656E-     prompt3	db	"Please enter the second number: ",00h	; third prompt & NULL
   143 0000004A 746572207468652073-
   143 00000053 65636F6E64206E756D-
   143 0000005C 6265723A2000       
   144 00000062 0000000000000000        num1	dq	00h
   145 0000006A 0000000000000000        num2	dq	00h
   146 00000072 20                      oper	db	20h
   147 00000073 0000000000000000        result	dq	00h
   148 0000007B 00                      rem 	db	00h
   149 0000007C 54686520524553554C-     resmsg	db	"The RESULT is: ",00h
   149 00000085 542069733A2000     
   150 0000008C 7468652052454D4149-     remmsg	db	"the REMAINDER is: ",00h
   150 00000095 4E4445522069733A20-
   150 0000009E 00                 
   151 0000009F 496E76616C6964206F-     errmsg	db	"Invalid operator.",00h
   151 000000A8 70657261746F722E00 
   152 000000B1 50726F6772616D2074-     eopmsg	db	"Program terminating.",00h
   152 000000BA 65726D696E6174696E-
   152 000000C3 672E00             
   153 000000C6 20<rep FFh>             ipbuffer times 	255 db 20h	; define buffer of spaces
   154                                  ipbuflen equ	$-ipbuffer
   155 000001C5 0000000000000000        multbuf	dq	00h	; multiplication result buffer
